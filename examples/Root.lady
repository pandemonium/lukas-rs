Token_Type ::=
    Type_Assign
  | Arrow
  | Identifier Text
  | Keyword    Keyword
  | Star | Gte | Plus

Keyword ::= Module | If

List ::= ∀α. Nil | Cons α (List α)

module List:
  head :: ∀α. List α -> Perhaps α :=
    λxs. deconstruct xs into Cons a tail -> This a | otherwise -> Nope

  tail :: ∀α. List α -> List α :=
    λxs. deconstruct xs into Cons a tail -> tail | tail -> tail

  fold_right :: ∀z α. (α -> z -> z) -> z -> List α -> z :=
    λf z xs.
      deconstruct xs into
        Cons a tail -> f a (fold_right f z tail)
      | Nil         -> z

  fold_left :: ∀z α. (z -> α -> z) -> z -> List α -> z :=
    λf z xs.
      deconstruct xs into
        Cons a tail -> fold_left f (f z a) tail
      | Nil         -> z

  map :: ∀α β. (α -> β) -> List α -> List β :=
    λf. fold_right (compose Cons f) Nil

  bind :: ∀α β. (α -> List β) -> List α -> List β :=
    λf. fold_right (λx. append (f x)) Nil

  cartesian :: ∀α β. List α -> List β -> List (α, β) :=
    λxs ys. bind (λx. map (λy. x, y) ys) xs

  zip :: ∀α β. List α -> List β -> List (α, β) := λxs ys.
    deconstruct xs, ys into
      Cons x xs, Cons y ys -> Cons (x, y) (zip xs ys)
    | otherwise            -> Nil

  append :: ∀α. List α -> List α -> List α :=
    λxs ys. fold_right Cons ys xs

  reverse :: ∀α. List α -> List α :=
    fold_left (λz a. Cons a z) Nil

  length :: ∀α. List α -> Int :=
    fold_right (λa z. 1 + z) 0

  count :: ∀α. (α -> Bool) -> List α -> Int :=
    λp. fold_left (λz x. if p x then 1 + z else z) 0

  filter :: ∀α. (α -> Bool) -> List α -> List α :=
    λp. bind (λx. if p x then Cons x Nil else Nil)

  flatten :: ∀α. List (List α) -> List α :=
    bind id

  tabulate :: ∀α. Int -> (Int -> α) -> List α :=
    λc f.
      let loop = λi xs.
        if i < c
          then loop (1 + i) (Cons (f i) xs)
          else xs
      in loop 0 Nil


Perhaps ::= ∀α. Nope | This α

module Perhaps:
  perhaps :: ∀α z. z -> (α -> z) -> Perhaps α -> z :=
    λz f xa. deconstruct xa into This x -> f x | otherwise -> z

  map :: ∀α β. (α -> β) -> Perhaps α -> Perhaps β :=
    λf. perhaps Nope (compose This f)

  bind :: ∀α β. (α -> Perhaps β) -> Perhaps α -> Perhaps β :=
    λf. perhaps Nope f

module Data.

foo :: ∀α e. Data.Result α e -> Int :=
  λr. 1

id :: ∀α. α -> α :=
  λx. x

flip :: ∀α β r. (α -> β -> r) -> β -> α -> r :=
  λf b a. f a b

compose :: ∀α β γ. (β -> γ) -> (α -> β) -> α -> γ :=
  λg f a. g (f a)

long_list := List.tabulate 1200 id

fibonacci :: Int -> Int := λn.
  if n = 0 or n = 1 then 1
  else fibonacci (n - 1) + fibonacci (n - 2)

clamp := lambda from to.
  fibonacci from, fibonacci to

frobnication :=
  deconstruct clamp 3 5 into
    p, q -> p * q


say_name := lambda name.
  "My name is; my name is: `name`, ..."

also_say_name :=
  say_name

say_it :=
  also_say_name

say_real_name := lambda fake real.
  print_endline "Formerly known as `say_it fake` but akshually `say_it real`"

any_expression := 420

and_function := λn. n * any_expression

order_number := This 66
order_number :: Perhaps Int := This 66

switch := lambda x.
  deconstruct
    x
  into
    1         -> "Eins"
  | 2         -> "Zwei"
  | otherwise -> "Polizei"


Dollars ::=
  { The_Good :: Int
    The_Bad  :: Text
    The_Ugly :: Perhaps Int
  }

make_one := lambda good bad.
  { The_Good := good; The_Bad := bad; The_Ugly := Nope }

dollars :: Text :=
  deconstruct
    make_one 1 "Sylvester"
  into
    { The_Good : good; The_Bad : bad; The_Ugly : This ugly } ->
        "`good`, `bad`, `ugly`"
  | { The_Good : good; The_Bad : bad; The_Ugly : Nope }       ->
        "`good`, `bad`"

einstein := lambda m c.
  let square = lambda c. c * c
  in m * square c

print_scientific_fact := lambda icewalls.
  print_endline if icewalls
    then "Earth has an interesting shape"
    else "Our princess is in another castle"

compute_earthiness := λr.
  let π = 3 in
  4/3 * π * r * r * r

whence :: forall a. Bool -> (Unit -> a) -> (Unit -> a) -> a :=
  lambda predicate consequent alternate.
    if predicate then consequent () else alternate ()

Expr ::= ∀α id.
    Var    α id
  | Lambda α id (Expr α id)
  | Apply  α (Expr α id) (Expr α id)
  | IntLit α Int

start := λx.
  print_scientific_fact false

  let round = true in
  let real = true in
  let flat = false in
  let surrounded_by_ice = true in
  let earth = round and real xor flat and surrounded_by_ice
  in print_endline "Earth is `earth`"

  whence false (λ_. print_endline "for it is true") (λ_. print_endline "unless false")

  let x = (λf. (f 1, f "hi"))
  in print_endline "hmm: `x id`"

  let thang =
    1, 2, "and to the 4"
  in print_endline "`thang.0`, `thang.1`, `thang.0 + thang.1` `thang.2`"

  print_endline "frobnication: `frobnication`"

  print_endline "`true and false or true`"

  let render = λx. "I, `x`, can be anything `and_function any_expression / 69`." in
  print_endline "... when I say the name, Biggus: `render "Optimus Prime"`?"

  say_real_name "Slim Shady" "Marshall Mathers"

  let x = Data.Fault 1 in
  print_endline (show x)

  let p = This 1 in
  print_endline "q: `Perhaps.map (λx. 10 * x) p`."

  print_endline "Hej `1`"

  let xs = long_list in
  let ys = List.map (λx. Cons x Nil) xs in
  List.count (λx. x > 1) (List.flatten ys)

  print_endline "long list is `List.length long_list` long."

  let ps = Cons 1 (Cons 2 (Cons 3 Nil)) in
  let qs = Cons "ett" (Cons "två" (Cons "tre" Nil)) in
  print_endline "zipped: `List.zip ps qs`"
